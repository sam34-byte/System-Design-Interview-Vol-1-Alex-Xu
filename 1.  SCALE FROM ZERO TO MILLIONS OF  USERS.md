#### Single Server Setup 

![[single-server-setup.png]]

	1. Users access websites through domain names, such as api.mysite.com. Usually, the Domain Name System (DNS) is a paid service provided by 3rd parties and not hosted by our servers. 

	2. Internet Protocol (IP) address is returned to the browser or mobile app. In the example, IP address 15.125.23.214 is returned. 

	3. Once the IP address is obtained, Hypertext Transfer Protocol requests are sent directly to your web server. 4. The web server returns HTML pages or JSON response for rendering.

The traffic to your web server comes from two sources  : 

	Web Application : uses a combination of server-side languages(Java, Python, etc.) to handle business logic, storage, etc., and client-side languages (HTML and JavaScript) for presentation.

	Mobile Application : HTTP protocol is the communication protocol between the mobile app and the web server. JavaScript Object Notation (JSON) is commonly used API response format to transfer data due to its simplicity.

Example of JSON API response : 
GET/users/12 - Retrieve user object for id = 12

```
{
	"id" : 12,
	"firstName" : "John",
	"lastName" : "Smith", 
	"address" :{
		"streetAddress" : "21 2nd Street", 
		"city" : "New York",
		"state" : "NY"
	}
}
```

#### Database

With the growth of the user base, one server is not enough, and we need multiple servers: one for web/mobile traffic, the other for the database.

Separating web/mobile traffic (web tier) and database (data tier) servers allows them to be scaled independently.

!![[database.png]]
#### Which databases to use ?

Relational databases(RDBMS) represent and store data in tables and row. You can perform join operations using SQL across different database tables.

Ex : MySQL, Oracle database, PostgreSQL etc.

Non-Relational databases(NoSQL) are grouped into four categories : 
- key-value stores
- column stores
- graph stores
- document stores

Join operations are generally not supported in non-relational databases.

Non-relational databases might be the right choice if: 
- application requires super-low latency
- data are unstructured, or you do not have any relational data
- only need to serialize and deserialize data(JSON, XML, YAML etc.)
- store a massive amount of data 

#### Vertical Scaling vs Horizontal Scaling


Vertical Scaling - the process of adding more power(CPU, RAM, etc.) to your servers
Horizontal Scaling - scale by adding more servers into your pool of resources

Horizontal scaling is more desirable for large scale applications due to the limitations of vertical scaling.
#### Load balancer 

Advantages of using Load Balancer
- Users are connected to the web server directly and will be unable to access the website if the we server is offline.
- If many users access the web server simultaneously and it reaches the web server's load limit, users generally experience slower response or fail to connect to the server.

A load balancer evenly distributes incoming traffic among web servers that are defined in a load-balanced set.

![[load-balancer.png]]


With the above setup, web servers are unreachable directly by clients anymore. For better security, private IPs are used for communications between servers. . A private IP is an IP address reachable only between servers in the same network; however, it is unreachable over the internet. The load balancer communicates with web servers through private IPs.

- If server 1 goes offline, all the traffic will be routed to server 2. This prevents the website from going offline. We will also add a new healthy web server to the server pool to balance the load.

- If the website traffic grows rapidly, and two servers are not enough to handle the traffic, the load balancer can handle this problem gracefully. You only need to add more servers to the web server pool, and the load balancer automatically starts to send requests to them


#### Database Replication

Single database does not support failover and redundancy. Database replication is a common technique to address those problems.

Database replication can be used in many database management systems, usually with a master/slave relationship between the original (master) and the copies (slaves)”.

A master database generally only supports write operations(insert, delete or update). 

A slave database gets copies of the data from the master database and only supports read operations. 

Most applications require a much higher ratio of reads to writes; thus, the number of slave databases in a system is usually larger than the number of master databases. 

![[database_replication.png]]

Advantages of database replication: 
- Better performance: In the master-slave model, all writes and updates happen in master nodes; whereas, read operations are distributed across slave nodes. This model improves performance because it allows more queries to be processed in parallel. 
- Reliability: If one of your database servers is destroyed by a natural disaster, such as a typhoon or an earthquake, data is still preserved. You do not need to worry about data loss because data is replicated across multiple locations. 
- High availability: By replicating data across different locations, your website remains in operation even if a database is offline as you can access data stored in another database server.

What if one of the databases goes offline ? 

-  If only one slave database is available and it goes offline, read operations will be directed to the master database temporarily. As soon as the issue is found, a new slave database will replace the old one. In case multiple slave databases are available, read operations are redirected to other healthy slave databases. A new database server will replace the old one. 

- If the master database goes offline, a slave database will be promoted to be the new master. All the database operations will be temporarily executed on the new master database. A new slave database will replace the old one for data replication immediately. In production systems, promoting a new master is more complicated as the data in a slave database might not be up to date. The missing data needs to be updated by running data recovery scripts. Although some other replication methods like multi-masters and circular replication could help, those setups are more complicated.

![[load_balancer_and_database_replication.png]]

• A user gets the IP address of the load balancer from DNS. 

• A user connects the load balancer with this IP address. • The HTTP request is routed to either Server 1 or Server 2. 

• A web server reads user data from a slave database. 

• A web server routes any data-modifying operations to the master database. This includes write, update, and delete operations.

#### Cache

A cache is a temporary storage area that stores the result of expensive responses or frequently accessed data in memory so that subsequent requests are served more quickly.

#### Cache Tier

A temporary data store layer, much faster than the database. 

Benefits :
- better system performance
- ability to reduce database workloads
- ability to scale the cache tier independently

![[cache-tier.png]]

The above caching strategy is called a read-through cache. 

Their are other caching strategies depending on the data type, size and access patterns.

Typical Memcached APIs : 

![[memcached-api.png]]

#### Consideration for using cache

- Decide when to use cache. Consider using cache when data is read frequently but modified infrequently. Since cached data is stored in volatile memory, a cache server is not ideal for persisting data. For instance, if a cache server restarts, all the data in memory is lost.
- Expiration policy. It is a good practice to implement an expiration policy. Once cached data is expired, it is removed from the cache. When there is no expiration policy, cached data will be stored in the memory permanently. It is advisable not to make the expiration date too short as this will cause the system to reload data from the database too frequently. Meanwhile, it is advisable not to make the expiration date too long as the data can become stale. 
- Consistency: This involves keeping the data store and the cache in sync. Inconsistency can happen because data-modifying operations on the data store and cache are not in a single transaction. When scaling across multiple regions, maintaining consistency between the data store and cache is challenging. Read “Scaling Memcache at Facebook” published by Facebook . 
- Mitigating failures: A single cache server represents a potential single point of failure (SPOF), defined in Wikipedia as follows: “A single point of failure (SPOF) is a part of a system that, if it fails, will stop the entire system from working”. As a result, multiple cache servers across different data centers are recommended to avoid SPOF. Another recommended approach is to overprovision the required memory by certain percentages. This provides a buffer as the memory usage increases.
![[single-point-of_failure.png]]
- Eviction Policy: Once the cache is full, any requests to add items to the cache might cause existing items to be removed. This is called cache eviction. Least-recently-used (LRU) is the most popular cache eviction policy. Other eviction policies, such as the Least Frequently Used (LFU) or First in First Out (FIFO), can be adopted to satisfy different use cases.

#### Content delivery network (CDN)